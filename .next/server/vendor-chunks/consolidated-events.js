"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/consolidated-events";
exports.ids = ["vendor-chunks/consolidated-events"];
exports.modules = {

/***/ "(ssr)/./node_modules/consolidated-events/lib/index.esm.js":
/*!***********************************************************!*\
  !*** ./node_modules/consolidated-events/lib/index.esm.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addEventListener: () => (/* binding */ addEventListener)\n/* harmony export */ });\nvar CAN_USE_DOM = !!( false && 0);\n// Adapted from Modernizr\n// https://github.com/Modernizr/Modernizr/blob/acb3f0d9/feature-detects/dom/passiveeventlisteners.js#L26-L37\nfunction testPassiveEventListeners() {\n    if (!CAN_USE_DOM) {\n        return false;\n    }\n    if (!window.addEventListener || !window.removeEventListener || !Object.defineProperty) {\n        return false;\n    }\n    var supportsPassiveOption = false;\n    try {\n        var opts = Object.defineProperty({}, \"passive\", {\n            // eslint-disable-next-line getter-return\n            get: function() {\n                function get() {\n                    supportsPassiveOption = true;\n                }\n                return get;\n            }()\n        });\n        var noop = function noop() {};\n        window.addEventListener(\"testPassiveEventSupport\", noop, opts);\n        window.removeEventListener(\"testPassiveEventSupport\", noop, opts);\n    } catch (e) {\n    // do nothing\n    }\n    return supportsPassiveOption;\n}\nvar memoized = void 0;\nfunction canUsePassiveEventListeners() {\n    if (memoized === undefined) {\n        memoized = testPassiveEventListeners();\n    }\n    return memoized;\n}\nfunction normalizeEventOptions(eventOptions) {\n    if (!eventOptions) {\n        return undefined;\n    }\n    if (!canUsePassiveEventListeners()) {\n        // If the browser does not support the passive option, then it is expecting\n        // a boolean for the options argument to specify whether it should use\n        // capture or not. In more modern browsers, this is passed via the `capture`\n        // option, so let's just hoist that value up.\n        return !!eventOptions.capture;\n    }\n    return eventOptions;\n}\n/* eslint-disable no-bitwise */ /**\n * Generate a unique key for any set of event options\n */ function eventOptionsKey(normalizedEventOptions) {\n    if (!normalizedEventOptions) {\n        return 0;\n    }\n    // If the browser does not support passive event listeners, the normalized\n    // event options will be a boolean.\n    if (normalizedEventOptions === true) {\n        return 100;\n    }\n    // At this point, the browser supports passive event listeners, so we expect\n    // the event options to be an object with possible properties of capture,\n    // passive, and once.\n    //\n    // We want to consistently return the same value, regardless of the order of\n    // these properties, so let's use binary maths to assign each property to a\n    // bit, and then add those together (with an offset to account for the\n    // booleans at the beginning of this function).\n    var capture = normalizedEventOptions.capture << 0;\n    var passive = normalizedEventOptions.passive << 1;\n    var once = normalizedEventOptions.once << 2;\n    return capture + passive + once;\n}\nfunction ensureCanMutateNextEventHandlers(eventHandlers) {\n    if (eventHandlers.handlers === eventHandlers.nextHandlers) {\n        // eslint-disable-next-line no-param-reassign\n        eventHandlers.nextHandlers = eventHandlers.handlers.slice();\n    }\n}\nfunction TargetEventHandlers(target) {\n    this.target = target;\n    this.events = {};\n}\nTargetEventHandlers.prototype.getEventHandlers = function() {\n    function getEventHandlers(eventName, options) {\n        var key = String(eventName) + \" \" + String(eventOptionsKey(options));\n        if (!this.events[key]) {\n            this.events[key] = {\n                handlers: [],\n                handleEvent: undefined\n            };\n            this.events[key].nextHandlers = this.events[key].handlers;\n        }\n        return this.events[key];\n    }\n    return getEventHandlers;\n}();\nTargetEventHandlers.prototype.handleEvent = function() {\n    function handleEvent(eventName, options, event) {\n        var eventHandlers = this.getEventHandlers(eventName, options);\n        eventHandlers.handlers = eventHandlers.nextHandlers;\n        eventHandlers.handlers.forEach(function(handler) {\n            if (handler) {\n                // We need to check for presence here because a handler function may\n                // cause later handlers to get removed. This can happen if you for\n                // instance have a waypoint that unmounts another waypoint as part of an\n                // onEnter/onLeave handler.\n                handler(event);\n            }\n        });\n    }\n    return handleEvent;\n}();\nTargetEventHandlers.prototype.add = function() {\n    function add(eventName, listener, options) {\n        var _this = this;\n        // options has already been normalized at this point.\n        var eventHandlers = this.getEventHandlers(eventName, options);\n        ensureCanMutateNextEventHandlers(eventHandlers);\n        if (eventHandlers.nextHandlers.length === 0) {\n            eventHandlers.handleEvent = this.handleEvent.bind(this, eventName, options);\n            this.target.addEventListener(eventName, eventHandlers.handleEvent, options);\n        }\n        eventHandlers.nextHandlers.push(listener);\n        var isSubscribed = true;\n        var unsubscribe = function() {\n            function unsubscribe() {\n                if (!isSubscribed) {\n                    return;\n                }\n                isSubscribed = false;\n                ensureCanMutateNextEventHandlers(eventHandlers);\n                var index = eventHandlers.nextHandlers.indexOf(listener);\n                eventHandlers.nextHandlers.splice(index, 1);\n                if (eventHandlers.nextHandlers.length === 0) {\n                    // All event handlers have been removed, so we want to remove the event\n                    // listener from the target node.\n                    if (_this.target) {\n                        // There can be a race condition where the target may no longer exist\n                        // when this function is called, e.g. when a React component is\n                        // unmounting. Guarding against this prevents the following error:\n                        //\n                        //   Cannot read property 'removeEventListener' of undefined\n                        _this.target.removeEventListener(eventName, eventHandlers.handleEvent, options);\n                    }\n                    eventHandlers.handleEvent = undefined;\n                }\n            }\n            return unsubscribe;\n        }();\n        return unsubscribe;\n    }\n    return add;\n}();\nvar EVENT_HANDLERS_KEY = \"__consolidated_events_handlers__\";\n// eslint-disable-next-line import/prefer-default-export\nfunction addEventListener(target, eventName, listener, options) {\n    if (!target[EVENT_HANDLERS_KEY]) {\n        // eslint-disable-next-line no-param-reassign\n        target[EVENT_HANDLERS_KEY] = new TargetEventHandlers(target);\n    }\n    var normalizedEventOptions = normalizeEventOptions(options);\n    return target[EVENT_HANDLERS_KEY].add(eventName, listener, normalizedEventOptions);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY29uc29saWRhdGVkLWV2ZW50cy9saWIvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxJQUFJQSxjQUFjLENBQUMsQ0FBRSxPQUFnRCxJQUFJQyxDQUE2QjtBQUV0Ryx5QkFBeUI7QUFDekIsNEdBQTRHO0FBQzVHLFNBQVNHO0lBQ1AsSUFBSSxDQUFDSixhQUFhO1FBQ2hCLE9BQU87SUFDVDtJQUVBLElBQUksQ0FBQ0MsT0FBT0ksZ0JBQWdCLElBQUksQ0FBQ0osT0FBT0ssbUJBQW1CLElBQUksQ0FBQ0MsT0FBT0MsY0FBYyxFQUFFO1FBQ3JGLE9BQU87SUFDVDtJQUVBLElBQUlDLHdCQUF3QjtJQUM1QixJQUFJO1FBQ0YsSUFBSUMsT0FBT0gsT0FBT0MsY0FBYyxDQUFDLENBQUMsR0FBRyxXQUFXO1lBQzlDLHlDQUF5QztZQUN6Q0csS0FBSztnQkFDSCxTQUFTQTtvQkFDUEYsd0JBQXdCO2dCQUMxQjtnQkFFQSxPQUFPRTtZQUNUO1FBQ0Y7UUFDQSxJQUFJQyxPQUFPLFNBQVNBLFFBQVE7UUFDNUJYLE9BQU9JLGdCQUFnQixDQUFDLDJCQUEyQk8sTUFBTUY7UUFDekRULE9BQU9LLG1CQUFtQixDQUFDLDJCQUEyQk0sTUFBTUY7SUFDOUQsRUFBRSxPQUFPRyxHQUFHO0lBQ1YsYUFBYTtJQUNmO0lBRUEsT0FBT0o7QUFDVDtBQUVBLElBQUlLLFdBQVcsS0FBSztBQUVwQixTQUFTQztJQUNQLElBQUlELGFBQWFFLFdBQVc7UUFDMUJGLFdBQVdWO0lBQ2I7SUFDQSxPQUFPVTtBQUNUO0FBRUEsU0FBU0csc0JBQXNCQyxZQUFZO0lBQ3pDLElBQUksQ0FBQ0EsY0FBYztRQUNqQixPQUFPRjtJQUNUO0lBRUEsSUFBSSxDQUFDRCwrQkFBK0I7UUFDbEMsMkVBQTJFO1FBQzNFLHNFQUFzRTtRQUN0RSw0RUFBNEU7UUFDNUUsNkNBQTZDO1FBQzdDLE9BQU8sQ0FBQyxDQUFDRyxhQUFhQyxPQUFPO0lBQy9CO0lBRUEsT0FB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U0E7Z0JBQ1AsSUFBSSxDQUFDRCxjQUFjO29CQUNqQjtnQkFDRjtnQkFFQUEsZUFBZTtnQkFFZnhCLGlDQUFpQ0M7Z0JBQ2pDLElBQUl5QixRQUFRekIsY0FBY0UsWUFBWSxDQUFDd0IsT0FBTyxDQUFDUjtnQkFDL0NsQixjQUFjRSxZQUFZLENBQUN5QixNQUFNLENBQUNGLE9BQU87Z0JBRXpDLElBQUl6QixjQUFjRSxZQUFZLENBQUNrQixNQUFNLEtBQUssR0FBRztvQkFDM0MsdUVBQXVFO29CQUN2RSxpQ0FBaUM7b0JBRWpDLElBQUlELE1BQU1kLE1BQU0sRUFBRTt3QkFDaEIscUVBQXFFO3dCQUNyRSwrREFBK0Q7d0JBQy9ELGtFQUFrRTt3QkFDbEUsRUFBRTt3QkFDRiw0REFBNEQ7d0JBQzVEYyxNQUFNZCxNQUFNLENBQUN4QixtQkFBbUIsQ0FBQzRCLFdBQVdULGNBQWNhLFdBQVcsRUFBRUg7b0JBQ3pFO29CQUVBVixjQUFjYSxXQUFXLEdBQUd0QjtnQkFDOUI7WUFDRjtZQUVBLE9BQU9pQztRQUNUO1FBQ0EsT0FBT0E7SUFDVDtJQUVBLE9BQU9QO0FBQ1Q7QUFFQSxJQUFJVyxxQkFBcUI7QUFFekIsd0RBQXdEO0FBQ3hELFNBQVNoRCxpQkFBaUJ5QixNQUFNLEVBQUVJLFNBQVMsRUFBRVMsUUFBUSxFQUFFUixPQUFPO0lBQzVELElBQUksQ0FBQ0wsTUFBTSxDQUFDdUIsbUJBQW1CLEVBQUU7UUFDL0IsNkNBQTZDO1FBQzdDdkIsTUFBTSxDQUFDdUIsbUJBQW1CLEdBQUcsSUFBSXhCLG9CQUFvQkM7SUFDdkQ7SUFDQSxJQUFJVCx5QkFBeUJKLHNCQUFzQmtCO0lBQ25ELE9BQU9MLE1BQU0sQ0FBQ3VCLG1CQUFtQixDQUFDWCxHQUFHLENBQUNSLFdBQVdTLFVBQVV0QjtBQUM3RDtBQUU0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2NvZGUtdG8taW1nLy4vbm9kZV9tb2R1bGVzL2NvbnNvbGlkYXRlZC1ldmVudHMvbGliL2luZGV4LmVzbS5qcz9kZTFjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBDQU5fVVNFX0RPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbi8vIEFkYXB0ZWQgZnJvbSBNb2Rlcm5penJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvYWNiM2YwZDkvZmVhdHVyZS1kZXRlY3RzL2RvbS9wYXNzaXZlZXZlbnRsaXN0ZW5lcnMuanMjTDI2LUwzN1xuZnVuY3Rpb24gdGVzdFBhc3NpdmVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKCFDQU5fVVNFX0RPTSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgIXdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyIHx8ICFPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgc3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG9wdHMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGdldHRlci1yZXR1cm5cbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgc3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXQ7XG4gICAgICB9KClcbiAgICB9KTtcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBub29wLCBvcHRzKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdFBhc3NpdmVFdmVudFN1cHBvcnQnLCBub29wLCBvcHRzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGRvIG5vdGhpbmdcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0c1Bhc3NpdmVPcHRpb247XG59XG5cbnZhciBtZW1vaXplZCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gY2FuVXNlUGFzc2l2ZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAobWVtb2l6ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgIG1lbW9pemVkID0gdGVzdFBhc3NpdmVFdmVudExpc3RlbmVycygpO1xuICB9XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRPcHRpb25zKGV2ZW50T3B0aW9ucykge1xuICBpZiAoIWV2ZW50T3B0aW9ucykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoIWNhblVzZVBhc3NpdmVFdmVudExpc3RlbmVycygpKSB7XG4gICAgLy8gSWYgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgcGFzc2l2ZSBvcHRpb24sIHRoZW4gaXQgaXMgZXhwZWN0aW5nXG4gICAgLy8gYSBib29sZWFuIGZvciB0aGUgb3B0aW9ucyBhcmd1bWVudCB0byBzcGVjaWZ5IHdoZXRoZXIgaXQgc2hvdWxkIHVzZVxuICAgIC8vIGNhcHR1cmUgb3Igbm90LiBJbiBtb3JlIG1vZGVybiBicm93c2VycywgdGhpcyBpcyBwYXNzZWQgdmlhIHRoZSBgY2FwdHVyZWBcbiAgICAvLyBvcHRpb24sIHNvIGxldCdzIGp1c3QgaG9pc3QgdGhhdCB2YWx1ZSB1cC5cbiAgICByZXR1cm4gISFldmVudE9wdGlvbnMuY2FwdHVyZTtcbiAgfVxuXG4gIHJldHVybiBldmVudE9wdGlvbnM7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHVuaXF1ZSBrZXkgZm9yIGFueSBzZXQgb2YgZXZlbnQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBldmVudE9wdGlvbnNLZXkobm9ybWFsaXplZEV2ZW50T3B0aW9ucykge1xuICBpZiAoIW5vcm1hbGl6ZWRFdmVudE9wdGlvbnMpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8vIElmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMsIHRoZSBub3JtYWxpemVkXG4gIC8vIGV2ZW50IG9wdGlvbnMgd2lsbCBiZSBhIGJvb2xlYW4uXG4gIGlmIChub3JtYWxpemVkRXZlbnRPcHRpb25zID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIDEwMDtcbiAgfVxuXG4gIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLCBzbyB3ZSBleHBlY3RcbiAgLy8gdGhlIGV2ZW50IG9wdGlvbnMgdG8gYmUgYW4gb2JqZWN0IHdpdGggcG9zc2libGUgcHJvcGVydGllcyBvZiBjYXB0dXJlLFxuICAvLyBwYXNzaXZlLCBhbmQgb25jZS5cbiAgLy9cbiAgLy8gV2Ugd2FudCB0byBjb25zaXN0ZW50bHkgcmV0dXJuIHRoZSBzYW1lIHZhbHVlLCByZWdhcmRsZXNzIG9mIHRoZSBvcmRlciBvZlxuICAvLyB0aGVzZSBwcm9wZXJ0aWVzLCBzbyBsZXQncyB1c2UgYmluYXJ5IG1hdGhzIHRvIGFzc2lnbiBlYWNoIHByb3BlcnR5IHRvIGFcbiAgLy8gYml0LCBhbmQgdGhlbiBhZGQgdGhvc2UgdG9nZXRoZXIgKHdpdGggYW4gb2Zmc2V0IHRvIGFjY291bnQgZm9yIHRoZVxuICAvLyBib29sZWFucyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoaXMgZnVuY3Rpb24pLlxuICB2YXIgY2FwdHVyZSA9IG5vcm1hbGl6ZWRFdmVudE9wdGlvbnMuY2FwdHVyZSA8PCAwO1xuICB2YXIgcGFzc2l2ZSA9IG5vcm1hbGl6ZWRFdmVudE9wdGlvbnMucGFzc2l2ZSA8PCAxO1xuICB2YXIgb25jZSA9IG5vcm1hbGl6ZWRFdmVudE9wdGlvbnMub25jZSA8PCAyO1xuICByZXR1cm4gY2FwdHVyZSArIHBhc3NpdmUgKyBvbmNlO1xufVxuXG5mdW5jdGlvbiBlbnN1cmVDYW5NdXRhdGVOZXh0RXZlbnRIYW5kbGVycyhldmVudEhhbmRsZXJzKSB7XG4gIGlmIChldmVudEhhbmRsZXJzLmhhbmRsZXJzID09PSBldmVudEhhbmRsZXJzLm5leHRIYW5kbGVycykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIGV2ZW50SGFuZGxlcnMubmV4dEhhbmRsZXJzID0gZXZlbnRIYW5kbGVycy5oYW5kbGVycy5zbGljZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRhcmdldEV2ZW50SGFuZGxlcnModGFyZ2V0KSB7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB0aGlzLmV2ZW50cyA9IHt9O1xufVxuXG5UYXJnZXRFdmVudEhhbmRsZXJzLnByb3RvdHlwZS5nZXRFdmVudEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBnZXRFdmVudEhhbmRsZXJzKGV2ZW50TmFtZSwgb3B0aW9ucykge1xuICAgIHZhciBrZXkgPSBTdHJpbmcoZXZlbnROYW1lKSArICcgJyArIFN0cmluZyhldmVudE9wdGlvbnNLZXkob3B0aW9ucykpO1xuXG4gICAgaWYgKCF0aGlzLmV2ZW50c1trZXldKSB7XG4gICAgICB0aGlzLmV2ZW50c1trZXldID0ge1xuICAgICAgICBoYW5kbGVyczogW10sXG4gICAgICAgIGhhbmRsZUV2ZW50OiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICB0aGlzLmV2ZW50c1trZXldLm5leHRIYW5kbGVycyA9IHRoaXMuZXZlbnRzW2tleV0uaGFuZGxlcnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzW2tleV07XG4gIH1cblxuICByZXR1cm4gZ2V0RXZlbnRIYW5kbGVycztcbn0oKTtcblxuVGFyZ2V0RXZlbnRIYW5kbGVycy5wcm90b3R5cGUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2ZW50TmFtZSwgb3B0aW9ucywgZXZlbnQpIHtcbiAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuZ2V0RXZlbnRIYW5kbGVycyhldmVudE5hbWUsIG9wdGlvbnMpO1xuICAgIGV2ZW50SGFuZGxlcnMuaGFuZGxlcnMgPSBldmVudEhhbmRsZXJzLm5leHRIYW5kbGVycztcbiAgICBldmVudEhhbmRsZXJzLmhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgZm9yIHByZXNlbmNlIGhlcmUgYmVjYXVzZSBhIGhhbmRsZXIgZnVuY3Rpb24gbWF5XG4gICAgICAgIC8vIGNhdXNlIGxhdGVyIGhhbmRsZXJzIHRvIGdldCByZW1vdmVkLiBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IGZvclxuICAgICAgICAvLyBpbnN0YW5jZSBoYXZlIGEgd2F5cG9pbnQgdGhhdCB1bm1vdW50cyBhbm90aGVyIHdheXBvaW50IGFzIHBhcnQgb2YgYW5cbiAgICAgICAgLy8gb25FbnRlci9vbkxlYXZlIGhhbmRsZXIuXG4gICAgICAgIGhhbmRsZXIoZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGhhbmRsZUV2ZW50O1xufSgpO1xuXG5UYXJnZXRFdmVudEhhbmRsZXJzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGFkZChldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIG9wdGlvbnMgaGFzIGFscmVhZHkgYmVlbiBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnQuXG4gICAgdmFyIGV2ZW50SGFuZGxlcnMgPSB0aGlzLmdldEV2ZW50SGFuZGxlcnMoZXZlbnROYW1lLCBvcHRpb25zKTtcblxuICAgIGVuc3VyZUNhbk11dGF0ZU5leHRFdmVudEhhbmRsZXJzKGV2ZW50SGFuZGxlcnMpO1xuXG4gICAgaWYgKGV2ZW50SGFuZGxlcnMubmV4dEhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZXZlbnRIYW5kbGVycy5oYW5kbGVFdmVudCA9IHRoaXMuaGFuZGxlRXZlbnQuYmluZCh0aGlzLCBldmVudE5hbWUsIG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLnRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVycy5oYW5kbGVFdmVudCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgZXZlbnRIYW5kbGVycy5uZXh0SGFuZGxlcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICB2YXIgaXNTdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICB2YXIgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKCFpc1N1YnNjcmliZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcblxuICAgICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0RXZlbnRIYW5kbGVycyhldmVudEhhbmRsZXJzKTtcbiAgICAgICAgdmFyIGluZGV4ID0gZXZlbnRIYW5kbGVycy5uZXh0SGFuZGxlcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgIGV2ZW50SGFuZGxlcnMubmV4dEhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgaWYgKGV2ZW50SGFuZGxlcnMubmV4dEhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIC8vIEFsbCBldmVudCBoYW5kbGVycyBoYXZlIGJlZW4gcmVtb3ZlZCwgc28gd2Ugd2FudCB0byByZW1vdmUgdGhlIGV2ZW50XG4gICAgICAgICAgLy8gbGlzdGVuZXIgZnJvbSB0aGUgdGFyZ2V0IG5vZGUuXG5cbiAgICAgICAgICBpZiAoX3RoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBjYW4gYmUgYSByYWNlIGNvbmRpdGlvbiB3aGVyZSB0aGUgdGFyZ2V0IG1heSBubyBsb25nZXIgZXhpc3RcbiAgICAgICAgICAgIC8vIHdoZW4gdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQsIGUuZy4gd2hlbiBhIFJlYWN0IGNvbXBvbmVudCBpc1xuICAgICAgICAgICAgLy8gdW5tb3VudGluZy4gR3VhcmRpbmcgYWdhaW5zdCB0aGlzIHByZXZlbnRzIHRoZSBmb2xsb3dpbmcgZXJyb3I6XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gICBDYW5ub3QgcmVhZCBwcm9wZXJ0eSAncmVtb3ZlRXZlbnRMaXN0ZW5lcicgb2YgdW5kZWZpbmVkXG4gICAgICAgICAgICBfdGhpcy50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50SGFuZGxlcnMuaGFuZGxlRXZlbnQsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV2ZW50SGFuZGxlcnMuaGFuZGxlRXZlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICAgIH0oKTtcbiAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gIH1cblxuICByZXR1cm4gYWRkO1xufSgpO1xuXG52YXIgRVZFTlRfSEFORExFUlNfS0VZID0gJ19fY29uc29saWRhdGVkX2V2ZW50c19oYW5kbGVyc19fJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9wcmVmZXItZGVmYXVsdC1leHBvcnRcbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIodGFyZ2V0LCBldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gIGlmICghdGFyZ2V0W0VWRU5UX0hBTkRMRVJTX0tFWV0pIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICB0YXJnZXRbRVZFTlRfSEFORExFUlNfS0VZXSA9IG5ldyBUYXJnZXRFdmVudEhhbmRsZXJzKHRhcmdldCk7XG4gIH1cbiAgdmFyIG5vcm1hbGl6ZWRFdmVudE9wdGlvbnMgPSBub3JtYWxpemVFdmVudE9wdGlvbnMob3B0aW9ucyk7XG4gIHJldHVybiB0YXJnZXRbRVZFTlRfSEFORExFUlNfS0VZXS5hZGQoZXZlbnROYW1lLCBsaXN0ZW5lciwgbm9ybWFsaXplZEV2ZW50T3B0aW9ucyk7XG59XG5cbmV4cG9ydCB7IGFkZEV2ZW50TGlzdGVuZXIgfTtcbiJdLCJuYW1lcyI6WyJDQU5fVVNFX0RPTSIsIndpbmRvdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInRlc3RQYXNzaXZlRXZlbnRMaXN0ZW5lcnMiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5Iiwic3VwcG9ydHNQYXNzaXZlT3B0aW9uIiwib3B0cyIsImdldCIsIm5vb3AiLCJlIiwibWVtb2l6ZWQiLCJjYW5Vc2VQYXNzaXZlRXZlbnRMaXN0ZW5lcnMiLCJ1bmRlZmluZWQiLCJub3JtYWxpemVFdmVudE9wdGlvbnMiLCJldmVudE9wdGlvbnMiLCJjYXB0dXJlIiwiZXZlbnRPcHRpb25zS2V5Iiwibm9ybWFsaXplZEV2ZW50T3B0aW9ucyIsInBhc3NpdmUiLCJvbmNlIiwiZW5zdXJlQ2FuTXV0YXRlTmV4dEV2ZW50SGFuZGxlcnMiLCJldmVudEhhbmRsZXJzIiwiaGFuZGxlcnMiLCJuZXh0SGFuZGxlcnMiLCJzbGljZSIsIlRhcmdldEV2ZW50SGFuZGxlcnMiLCJ0YXJnZXQiLCJldmVudHMiLCJwcm90b3R5cGUiLCJnZXRFdmVudEhhbmRsZXJzIiwiZXZlbnROYW1lIiwib3B0aW9ucyIsImtleSIsIlN0cmluZyIsImhhbmRsZUV2ZW50IiwiZXZlbnQiLCJmb3JFYWNoIiwiaGFuZGxlciIsImFkZCIsImxpc3RlbmVyIiwiX3RoaXMiLCJsZW5ndGgiLCJiaW5kIiwicHVzaCIsImlzU3Vic2NyaWJlZCIsInVuc3Vic2NyaWJlIiwiaW5kZXgiLCJpbmRleE9mIiwic3BsaWNlIiwiRVZFTlRfSEFORExFUlNfS0VZIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/consolidated-events/lib/index.esm.js\n");

/***/ })

};
;